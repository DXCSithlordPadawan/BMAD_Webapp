# FIPS 140-3 Cryptographic Compliance Guide

## Overview

This document describes how BMAD Forge implements cryptographic controls in compliance with Federal Information Processing Standard (FIPS) 140-3. FIPS 140-3 specifies security requirements for cryptographic modules used to protect sensitive information.

## Compliance Summary

| Requirement Area | Status | Implementation |
|------------------|--------|----------------|
| Cryptographic Module | Compliant | OpenSSL FIPS Provider |
| Approved Algorithms | Compliant | AES-256, SHA-256/384/512, RSA-2048+ |
| Key Management | Compliant | Secure generation, storage, rotation |
| Self-Tests | Compliant | Runtime algorithm verification |
| Physical Security | N/A | Software-only module |

---

## Cryptographic Module Specification

### Module Identification

| Attribute | Value |
|-----------|-------|
| Module Name | OpenSSL FIPS Provider |
| Module Version | 3.0.x |
| Module Type | Software |
| FIPS Certificate | #4282 |
| Security Level | Level 1 |

### Module Boundary

The cryptographic boundary encompasses:
- OpenSSL FIPS provider library
- Python cryptography library (using OpenSSL backend)
- Django's cryptographic functions (SECRET_KEY operations)

```
┌─────────────────────────────────────────────────────────────┐
│                    BMAD Forge Application                    │
├─────────────────────────────────────────────────────────────┤
│                     Django Framework                         │
│  ┌─────────────────────────────────────────────────────┐    │
│  │           Python cryptography Library                │    │
│  │  ┌─────────────────────────────────────────────┐    │    │
│  │  │         OpenSSL FIPS Provider               │    │    │
│  │  │  ┌─────────────────────────────────────┐    │    │    │
│  │  │  │    Approved Cryptographic            │    │    │    │
│  │  │  │         Algorithms                   │    │    │    │
│  │  │  │  • AES-256-GCM                       │    │    │    │
│  │  │  │  • SHA-256/384/512                   │    │    │    │
│  │  │  │  • RSA-2048/4096                     │    │    │    │
│  │  │  │  • ECDSA P-256/P-384                 │    │    │    │
│  │  │  │  • HMAC-SHA-256                      │    │    │    │
│  │  │  │  • PBKDF2                            │    │    │    │
│  │  │  └─────────────────────────────────────┘    │    │    │
│  │  │           CRYPTOGRAPHIC BOUNDARY            │    │    │
│  │  └─────────────────────────────────────────────┘    │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

---

## Approved Algorithms

### Symmetric Encryption

| Algorithm | Key Size | Mode | Use Case |
|-----------|----------|------|----------|
| AES | 256 bits | GCM | Data encryption at rest |
| AES | 256 bits | CBC | Session data encryption |

### Hash Functions

| Algorithm | Output Size | Use Case |
|-----------|-------------|----------|
| SHA-256 | 256 bits | Password hashing, integrity checks |
| SHA-384 | 384 bits | Digital signatures |
| SHA-512 | 512 bits | Key derivation |

### Asymmetric Algorithms

| Algorithm | Key Size | Use Case |
|-----------|----------|----------|
| RSA | 2048+ bits | TLS certificates, key exchange |
| ECDSA | P-256, P-384 | Digital signatures |
| ECDH | P-256, P-384 | Key agreement |

### Key Derivation Functions

| Algorithm | Parameters | Use Case |
|-----------|------------|----------|
| PBKDF2-HMAC-SHA256 | 600,000 iterations | Password hashing |
| HKDF-SHA256 | - | Key derivation |

---

## Key Management

### Key Generation

All cryptographic keys are generated using FIPS-approved random number generators.

```python
# Key generation example using FIPS-compliant RNG
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.backends import default_backend
import os

def generate_key():
    """Generate a FIPS-compliant encryption key."""
    # Use OS-provided CSPRNG (FIPS-approved)
    salt = os.urandom(32)
    password = os.urandom(32)

    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=600000,  # NIST SP 800-132 recommendation
        backend=default_backend()
    )
    return kdf.derive(password)
```

### Key Storage

| Key Type | Storage Method | Protection |
|----------|----------------|------------|
| SECRET_KEY | Environment variable | Encrypted at rest via cloud KMS |
| Database passwords | Environment variable | Encrypted via cloud secrets manager |
| TLS private keys | File system | Permissions 400, encrypted volume |
| API tokens | Database | Hashed with PBKDF2 |

### Key Rotation

| Key Type | Rotation Period | Procedure |
|----------|-----------------|-----------|
| SECRET_KEY | 90 days | Blue-green deployment with session migration |
| TLS certificates | Before expiration | Automated via cert-manager |
| Database passwords | 90 days | Coordinated database/app update |
| API tokens | On-demand | User-initiated regeneration |

**Key Rotation Procedure:**

```python
# settings/production.py
# Support multiple SECRET_KEYs during rotation
SECRET_KEY = os.environ.get('SECRET_KEY')
SECRET_KEY_FALLBACKS = [
    os.environ.get('SECRET_KEY_PREVIOUS', ''),
]

# Graceful key rotation support
SIGNING_BACKEND = 'django.core.signing.TimestampSigner'
```

---

## Self-Tests

### Power-On Self-Tests (POST)

The cryptographic module performs the following tests at startup:

| Test | Algorithm | Expected Result |
|------|-----------|-----------------|
| Known Answer Test | AES-256-GCM | Matches expected ciphertext |
| Known Answer Test | SHA-256 | Matches expected digest |
| Known Answer Test | HMAC-SHA-256 | Matches expected MAC |
| Known Answer Test | RSA | Signature verification passes |

### Conditional Self-Tests

| Trigger | Test Performed |
|---------|----------------|
| Key generation | Key pair consistency test |
| Random number generation | Continuous RNG test |
| Algorithm invocation | Output validation |

### Verification Script

```python
#!/usr/bin/env python
"""FIPS 140-3 self-test verification script."""

import hashlib
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import os

def verify_aes_kat():
    """AES Known Answer Test."""
    # NIST test vector
    key = bytes.fromhex('000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f')
    plaintext = bytes.fromhex('00112233445566778899aabbccddeeff')
    expected = bytes.fromhex('8ea2b7ca516745bfeafc49904b496089')

    cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())
    encryptor = cipher.encryptor()
    ciphertext = encryptor.update(plaintext) + encryptor.finalize()

    assert ciphertext == expected, "AES KAT failed"
    print("✓ AES-256 Known Answer Test passed")

def verify_sha256_kat():
    """SHA-256 Known Answer Test."""
    message = b"abc"
    expected = "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"

    digest = hashlib.sha256(message).hexdigest()
    assert digest == expected, "SHA-256 KAT failed"
    print("✓ SHA-256 Known Answer Test passed")

def verify_rng():
    """Continuous RNG test."""
    # Generate two random blocks and verify they differ
    block1 = os.urandom(32)
    block2 = os.urandom(32)

    assert block1 != block2, "RNG produced identical outputs"
    assert len(block1) == 32, "RNG output length incorrect"
    print("✓ RNG Continuous Test passed")

if __name__ == "__main__":
    verify_aes_kat()
    verify_sha256_kat()
    verify_rng()
    print("\nAll FIPS self-tests passed")
```

---

## TLS Configuration

### Approved Cipher Suites

```nginx
# nginx TLS configuration
ssl_protocols TLSv1.2 TLSv1.3;
ssl_ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;
ssl_prefer_server_ciphers off;
ssl_ecdh_curve secp384r1;
```

### Django TLS Settings

```python
# settings/production.py
SECURE_SSL_REDIRECT = True
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')

# HSTS
SECURE_HSTS_SECONDS = 31536000
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True
```

---

## Password Storage

### PBKDF2 Configuration

```python
# settings/base.py
PASSWORD_HASHERS = [
    'django.contrib.auth.hashers.PBKDF2PasswordHasher',
]

# Custom hasher with FIPS-compliant parameters
from django.contrib.auth.hashers import PBKDF2PasswordHasher

class FIPSPBKDF2PasswordHasher(PBKDF2PasswordHasher):
    """FIPS 140-3 compliant password hasher."""
    algorithm = "pbkdf2_sha256"
    iterations = 600000  # NIST SP 800-132 minimum for 2026
    digest = hashlib.sha256
```

---

## Audit Requirements

### Cryptographic Operations Logged

| Operation | Log Fields |
|-----------|------------|
| Key generation | Timestamp, key identifier, algorithm |
| Encryption | Timestamp, algorithm, success/failure |
| Decryption | Timestamp, algorithm, success/failure |
| Signature | Timestamp, algorithm, key identifier |
| Self-test | Timestamp, test type, result |

### Log Format

```json
{
    "timestamp": "2026-01-29T12:00:00Z",
    "event_type": "crypto_operation",
    "operation": "encrypt",
    "algorithm": "AES-256-GCM",
    "key_id": "db-encryption-key-v2",
    "status": "success",
    "module": "openssl_fips"
}
```

---

## Non-Approved Algorithms

The following algorithms are explicitly NOT used in BMAD Forge:

| Algorithm | Reason |
|-----------|--------|
| MD5 | Not FIPS-approved, collision vulnerabilities |
| SHA-1 | Deprecated for signatures |
| DES/3DES | Key size insufficient |
| RC4 | Not FIPS-approved |
| RSA < 2048 | Key size insufficient |

---

## Compliance Verification

### Verification Commands

```bash
# Verify OpenSSL FIPS mode
openssl version -a | grep FIPS

# Check enabled algorithms
openssl list -digest-algorithms
openssl list -cipher-algorithms

# Verify TLS configuration
nmap --script ssl-enum-ciphers -p 443 example.com

# Test FIPS self-tests
python -c "from cryptography.hazmat.backends.openssl import backend; print(backend._fips_enabled)"
```

### Compliance Checklist

- [ ] OpenSSL compiled with FIPS provider
- [ ] Only FIPS-approved algorithms in use
- [ ] Key lengths meet minimum requirements
- [ ] Self-tests executing at startup
- [ ] Cryptographic operations logged
- [ ] Keys stored securely
- [ ] Key rotation procedures documented

---

## References

- [NIST FIPS 140-3](https://csrc.nist.gov/publications/detail/fips/140/3/final)
- [NIST SP 800-131A Rev. 2](https://csrc.nist.gov/publications/detail/sp/800-131a/rev-2/final)
- [NIST SP 800-132](https://csrc.nist.gov/publications/detail/sp/800-132/final)
- [OpenSSL FIPS Module User Guide](https://www.openssl.org/docs/fips.html)

---

## Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2026-01-29 | Security Team | Initial document |
